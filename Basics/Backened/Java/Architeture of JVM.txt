Architeture of JVM
What is JVM:
	 we all know that java runtime enivornment(JRE) will execute the bytecode. but JRE is a part of JVM that analysis,interprets and execute the bytecode or .classFile to machine understandable code.
	 
Generally java was developed with the concept of WORA(Write Once Run Anywhere) which runs on a Virtual Machine(VM).

Basically JVM is divided into three subsystems:
1.Class Loader subsystem
2.Runtime Data Area
3.Execution Engine

1 Class Loader SubSystem:
	Java's dynamic class loading functionality is handled by the class loader subsystem. 
	It loads,links and initializes the class file which refers for the first time at runtime, not at compile time.
	
	1.1. Loading:
				Classes will be loaded by this component.
				Three types of loaders are there:
				1.BootStrap ClassLoader:-> Reaponsible for loading classes from bootStrap Classpath i.e runtime library jar file (rt.jar) which is located in jre/lib. Highest Priority is given to this classLoader.
				2.Extension ClassLoader:-> Reaponsible for loading classes which are inside jre/lib folder.
				3.Application ClassLoader:-> Reaponsible for loading Application level Classpath i.e path mentioned in enivornment varibles of the system.
	The  above classLoader will follow Delegation Hierarchy Algorithm while Loading the classFiles. 
	
	1.2. Linking:
				It ha s also three stages
				1.Verify:->Bytecode Verifier will verify the generated bytecode is correct or not. if verifiction fails then it will throw Verification error.
				2.Prepare:->For all static varibles memeory will be allocated and assignes a default value to that varibles.
				3.Resolve:->All symbolic references are replaced with original references from Method Area.
	
	1.3. Initialization:
				This is the final phase in ClassLoader subsystem here all static varibles are assigned with original values and the static block will be executed.
				
2.Runtime Data Area:
	the runtime data area is divided into five major components:
	1. Method Area:-> All the class level data is stored here including static varibles. 
					  There is only one Method Area per JVM. and it is a shared resource.
					  
	2.Heap Area:-> All the Objects and their cooresponding instance variables and arrays are stored here.
				   There is only one Heap Area per JVM.
				   Since the Method and Heap areas share memory for multiple threads. Hence the data stored is not thread safe.

	3.Stack Area:-> a.For Every thread, a separate runtime stack will be created.
					b.For every method call, one entry will be made in the stack memory which is called stack frame.
					c.All local varibles are created in stack memeory. The stack area is thread safe hence it is not a shared resource.
					
					The Stack Frame is divided into three sub entities:->
					1.Locale Variable Array:->Related to the method, how many local variables are involved and their cooresponding values are stored here.
					2.Operand Stack:-> if any intermediate operation is required to perform, Operand stack acts as runtime workspace to perform the operation.
					3.Frame data:-> All symbols corresponding to the methods are stored here. in case of exception, the catch block information will be maintained in the frame data.
	
	4.PC Registers:-> Each thread has separte PC Registers, to hold the address of current instruction. once the instruction is executed then PC Registers wil be updated to the next instruction.
	
	5.Native Method Stacks:-> native Method Stack holds native method information. for every thread there a separate native method stack is created.
	
3.Execution Engine:
			The bytecode, which is assigned to the Runtime Data Area, will be executed by the Execution Engine. 
			 The Execution Engine reads the bytecode and executes it piece by piece.
		
		1.Interpreter:->
		The interpreter interprets the bytecode faster but executes slowly. 
		The disadvantage of the interpreter is that when one method is called multiple times, every time a new interpretation is required.
		
		2.JIT Compiler:->
		The JIT Compiler neutralizes the disadvantage of the interpreter. 
		The Execution Engine will be using the help of the interpreter in converting byte code,
		but when it finds repeated code it uses the JIT compiler, 
		which compiles the entire bytecode and changes it to native code. 
		This native code will be used directly for repeated method calls, which improve the performance of the system.
		  1.Intermediate Code Generator – Produces intermediate code
		  2.Code Optimizer – Responsible for optimizing the intermediate code generated above
		  3.Target Code Generator – Responsible for Generating Machine Code or Native Code
		  4.Profiler – A special component, responsible for finding hotspots, i.e. whether the method is called multiple times or not.
		  
		3.Garbage Collector:->
				Collects and removes unreferenced objects. Garbage Collection can be triggered by calling System.gc(), 
				but the execution is not guaranteed. Garbage collection of the JVM collects the objects that are created.

		Java Native Interface (JNI):->
		JNI will be interacting with the Native Method Libraries and provides the Native Libraries required for the Execution Engine.
		
		Native Method Libraries:->
		This is a collection of the Native Libraries, which is required for the Execution Engine.
		